#!/bin/sh

REMOTE_STABLE_GIT="/home/gregkh/linux/stable/linux-stable/"
REMOTE_WORK="/home/gregkh/tmp/"
REMOTE_SERVER="build"
REMOTE_USER="gregkh"

#ssh root@MachineB 'bash -s' < local_script.sh

LOCAL_WORK="/tmp/"

KERNEL_VERSION="3.0"
OUTPUT_DIR="/tmp"
LINUX_STABLE="/home/gregkh/linux/stable/linux-stable/"
QUEUE_DIR="/home/gregkh/linux/stable/stable-queue/"

SCRIPT_HOME=`mktemp -d ${LOCAL_WORK}/stable_test_XXXXX`
echo "using ${SCRIPT_HOME} for our local files"
REMOTE_HOME=`basename ${SCRIPT_HOME}`
REMOTE_DIR=${REMOTE_WORK}/${REMOTE_HOME}
echo "using ${REMOTE_DIR} for the remote directory"


# tar up stable patch queue for just this kernel version
cd ${QUEUE_DIR}/queue-${KERNEL_VERSION}/
tar -c . | gzip > ${SCRIPT_HOME}/stable_queue.tar.gz

# create the script to run remotely

cat << __EOF__ > ${SCRIPT_HOME}/run_test.sh
#~/bin/sh
# Test script for the ${KERNEL_VERSION}-stable kernel
STABLE_GIT="${REMOTE_STABLE_GIT}"
HOME="${REMOTE_WORK}/${REMOTE_HOME}"
KERNEL_VERSION="${KERNEL_VERSION}"
PATCHES="stable_queue.tar.gz"

# create the directory we are going to work out of
mkdir \${HOME}
cd \${HOME}

# get the quilt patches in here somehow...
# FIXME


# create the linux clone
git clone -s ${REMOTE_STABLE_GIT} linux
cd linux

# checkout the branch we need
git checkout -t -b linux-${KERNEL_VERSION}.y origin/linux-${KERNEL_VERSION}.y

# create a patches/ directory for the stable patches to apply
mkdir patches
cd patches
tar -zxvf ${HOME}/\${PATCHES}
cd ..

# Apply the patch queue
QUILT_PATCHES=patches QUILT_SERIES=patches/series quilt push -aq --quiltrc

# build stuff
perl ../ktest.pl ../ktest.conf

#

__EOF__
chmod 755 ${SCRIPT_HOME}/run_test.sh

# create the ktest.conf file
cat <<__EOF__ > ${SCRIPT_HOME}/ktest.conf
TEST_START
TEST_TYPE = build

DEFAULTS
BUILD_TYPE = allmodconfig
OUTPUT_DIR = \${PWD}/output
LOG_FILE = \${PWD}/log
LOCALVERSION = -test
BUILD_OPTIONS = -j16
MACHINE = aws
BUILD_DIR = \${PWD}
__EOF__

cp /home/gregkh/linux/gregkh/tools/testing/ktest/ktest.pl ${SCRIPT_HOME}

# create the remote directory
ssh ${REMOTE_USER}@${REMOTE_SERVER} mkdir ${REMOTE_DIR}
scp ${SCRIPT_HOME}/* ${REMOTE_USER}@${REMOTE_SERVER}:${REMOTE_DIR}
ssh ${REMOTE_USER}@${REMOTE_SERVER} "cd ${REMOTE_DIR} && ./run_test.sh"


exit



TESTDIR=`pwd`
PATCHDIR="$TESTDIR/staging"
BUILDDIR="$TESTDIR/linux-staging"
LOG="$TESTDIR/log-stage"
GIT_LOCAL="greg@aria:git/staging.git"
GIT_REMOTE="git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging.git"

HOSTNAME=`hostname`

ONE_SHOT=$1

echo "PATCHDIR=$PATCHDIR"
echo "BUILDDIR=$BUILDDIR"

echo "cleaning up from any previous runs"
rm -rf $BUILDDIR
rm $LOG $LOG.run1 $LOG.run2

# If we are a machine on the local network, don't download the kernel.org
# version of the patch repo
if [ $HOSTNAME = "kvm" ]; then
	PATCH_REPO=$GIT_LOCAL
elif [ $HOSTNAME = "mini" ]; then
	PATCH_REPO=$GIT_LOCAL
else
	PATCH_REPO=$GIT_REMOTE
fi

if [ -d $PATCHDIR ]; then
	# just pull, don't clone a whole new tree
	cd $PATCHDIR
	git pull
	cd ..
else
	# check out latest version of patches
	git clone $PATCH_REPO $PATCHDIR
fi

VERSION=`cat $PATCHDIR/version`

echo "working with kernel version $VERSION"

# get latest version of kernel based on patch level
mkdir $BUILDDIR
cd $BUILDDIR
ketchup $VERSION

FAILED=0
J=$(expr $(grep processor /proc/cpuinfo | wc -l) \* 4)

if [ "X$ONE_SHOTX" == "XX" ] ; then
	# do a build first to set a baseline
	make allmodconfig
	nice -20 make -j$J 2> $LOG.run1 || FAILED=1
	if [ "$FAILED" != "0" ]; then
		echo "initial build FAILED!"
		echo "see $LOG.run1 for what happened"
		exit $FAILED
	fi

	# now clean up and do a second build with our patches
	make distclean
fi

# apply all patches
QUILT_PATCHES=$PATCHDIR QUILT_SERIES=$PATCHDIR/series quilt push -aq --quiltrc

# build for allmodconfig
make allmodconfig
#make -j4 &> $LOG
nice -20 make -j$J 2> $LOG.run2 || FAILED=1
if [ "$FAILED" != "0" ]; then
	echo "initial build FAILED!"
	echo "see $LOG.run2 for what happened"
	exit $FAILED
fi

diff -u $LOG.run1 $LOG.run2
